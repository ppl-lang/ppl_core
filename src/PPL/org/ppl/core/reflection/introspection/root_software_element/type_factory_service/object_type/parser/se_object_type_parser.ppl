// SPDX-License-Identifier: GPL-2.0-only
// Copyright (C) 2015 - 2021 Christian Neumanns, email: chris@ppl-lang.dev

service object_type_parser

    java_header
        import org.ppl.core.reflection.java.annotation.PPLObjectReference;
    end java_header

    java
        public static ty_object_type objectReferenceAnnotation_to_object_type (
            PPLObjectReference objectReferenceAnnotation ) {

            return parse_object_type_or_throw ( new fa_string ( objectReferenceAnnotation.type() ) );
        }
    end java

    attributes type:regex access:private
        type_path_regex = regex.create ( "[^ <>:,]+" )            
    .

    // This function assumes that the input is a valid string as generated by ty_object_type.to_string
    
    function parse_object_type_or_throw ( string ) -> object_type
    
        const scanner = text_scanner.create ( string )
        const object_type = parse_object_type ( scanner )
        assert not scanner.has_more
        
        return object_type
    .

    functions access:private
    
        parse_object_type ( scanner text_scanner ) -> object_type
        
            const first_object_type = parse_single_object_type ( scanner )
            if not scanner.is_at_string ( " or " ) then
                return first_object_type
            .
             
            const union_members = mutable_list<non_union_object_type>.create
            union_members.append ( first_object_type )

            repeat while scanner.skip_string ( " or " )
                union_members.append ( parse_single_object_type ( scanner ) )
            .
            
            return union_object_type.create (
                members = union_members.make_immutable
                known_parent_object_type = null )
        .

        parse_single_object_type ( scanner text_scanner ) -> non_union_object_type

            const path = scanner.consume_regex ( a_type_path_regex )
            assert path is not null
            
            if path.starts_with ( se_enumerated_object_type_constants.to_string_prefix ) then
                return enumerated_object_type.create ( type_path.create ( path.remove_first ) )
                    
            else if path.starts_with ( se_type_parameter_object_type_constants.to_string_prefix ) then
                return type_parameter_object_type.create (
                    type_parameter.create (
                        id = type_parameter_id.create ( path.remove_first )
                        child_of_type = null
                        parent_of_type = null
                        used_for_input = no
                        used_for_output = yes ) )
            .
            
            if scanner.skip_character ( '<' ) then
                const type_parameters = parse_generic_parameters ( scanner )
                return generified_object_type.create (
                    type_path = type_path.create ( path )
                    type_parameters )
            else
                const type_path = type_path.create ( path )
                case value of type_path.id.value
                    when "any"
                        return se_common_object_types.any
                    when "null"
                        return se_common_object_types.null
                    when "non_null"
                        return se_common_object_types.non_null
                    when "none"
                        return se_common_object_types.none
                    otherwise
                        return standard_object_type.create ( type_path )
                .
            .
        .
        
        parse_generic_parameters ( scanner text_scanner ) \
            -> map<key:type_parameter_id, value:type_parameter_assignment> or null
            
            if scanner.skip_string ( "*>" ) then
                return null
            .
            
            const r = mutable_map<key:type_parameter_id, value:type_parameter_assignment>.create
            
            repeat while not scanner.skip_string ( ">" )
                
                const id_string = scanner.consume_all_to_character_excluding ( ':' )
                assert id_string is not null
                const id = type_parameter_id.create ( id_string )

                scanner.consume_current_character
                
                variable kind type_parameter_assignment_kind
                if scanner.skip_string ( "child_of:" ) then
                    kind = type_parameter_assignment_kind.child_of
                else if scanner.skip_string ( "parent_of:" ) then
                    kind = type_parameter_assignment_kind.parent_of
                else if scanner.skip_string ( "only:" ) then
                    kind = type_parameter_assignment_kind.only
                else if scanner.skip_string ( "*" ) then
                    kind = type_parameter_assignment_kind.wildcard
                else
                    kind = type_parameter_assignment_kind.default
                .
                
                const object_type = \
                    if kind #r type_parameter_assignment_kind.wildcard \
                    then parse_object_type ( scanner ) \
                    else null
                
                r.add (
                    key = id
                    value = type_parameter_assignment.create ( id, object_type, kind ) )
                
                scanner.skip_string ( ", " )
            .

            return r.make_immutable
        .
    .
    
    tests
        // string
        
        variable parse_string = se_common_type_paths.string.value
        variable r object_type = parse_object_type_or_throw ( parse_string )
        case type of r
            when standard_object_type
            otherwise
                verify no
        .
        verify r.to_string =v "string"
        verify r.to_long_string =v parse_string
        
        
        // string or null
        
        parse_string = """{{se_common_type_paths.string}} or {{se_common_type_paths.null}}"""
        r = parse_object_type_or_throw ( parse_string )
        case type of r
            when union_object_type c
                verify c.is_nullable
            otherwise
                verify no
        .
        verify r.to_string =v "string or null"
        verify r.to_long_string =v parse_string
        
        
        // enum ty_comparator_result
        
        parse_string = "!org.ppl.core.basics.common_extensions.object_comparison.ty_comparator_result"
        r = parse_object_type_or_throw ( parse_string )
        case type of r
            when enumerated_object_type
            otherwise
                verify no
        .
        verify r.to_long_string =v parse_string
        verify r.to_string =v "!comparator_result"
        
        
        // generic map<key:string, value:character or null>

        parse_string = """org.ppl.core.collections.maps.ty_map<key:{{se_common_type_paths.string}}, value:{{se_common_type_paths.character}}>"""
        r = parse_object_type_or_throw ( parse_string )
        case type of r
            when generified_object_type
            otherwise
                verify no
        .
        verify r.to_string =v "map<key:string, value:character>"
        verify r.to_long_string =v parse_string
        
        
        // type parameter $item

        parse_string = "$item"
        r = parse_object_type_or_throw ( parse_string )
        case type of r
            when type_parameter_object_type
            otherwise
                verify no
        .
        verify r.to_string =v "$item"
        verify r.to_long_string =v "$item"

///
        r = parse_object_type_or_throw ( "l1.l2.ty_string or l1.ty_yes_no or null" )
        case type of r
            when union_object_type
            otherwise
                verify no
        .
        verify r.is_nullable
        verify r.to_string =v "l1.l2.ty_string or l1.ty_yes_no or null"
        verify r.to_string =v "string or yes_no or null"
        
        r = parse_object_type_or_throw ( "l1.l2.ty_list<element:$value> or null" )
        verify r.is_nullable
        verify r.to_string =v "l1.l2.ty_list<element:$value> or null"
        verify r.to_string =v "list<element:value> or null"

        r = parse_object_type_or_throw ( "l1.l2.ty_list<element:child_of:$value> or null" )
        verify r.is_nullable
        verify r.to_string =v "l1.l2.ty_list<element:child_of:$value> or null"
        verify r.to_string =v "list<element:child_of:value> or null"

        r = parse_object_type_or_throw ( "l1.l2.ty_foo<p1:li.ty_p1, p2:child_of:$value or null, p3:parent_of:l1.ty_p3, p4:only:l1.ty_p4 or null, p5:*>" )
        verify not r.is_nullable
        verify r.to_string =v "l1.l2.ty_foo<p1:li.ty_p1, p2:child_of:$value or null, p3:parent_of:l1.ty_p3, p4:only:l1.ty_p4 or null, p5:*>"
        verify r.to_string =v "foo<p1:p1, p2:child_of:value or null, p3:parent_of:p3, p4:only:p4 or null, p5:*>"
.///
    .
.
